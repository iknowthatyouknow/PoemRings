<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Load the music library loader FIRST (cache-busted) -->
  <script src="index.js?v=10" defer></script>

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>If Only</title>
  <style>
    :root{
      --spin-duration: 1200ms;
      --stair-fraction: 0.25;
      --line-stagger: 300ms;
      --line-fade-dur: 1200ms;

      /* Desktop defaults (match v44) */
      --ring-width: 760px;
      --ring-height: 76px;

      /* Crossfade duration */
      --xfade-ms: 1800ms;

      --bg-1: #0e1117;
      --bg-2: #0b0e14;
      --panel: #121826;
      --panel-2: #141b2a;
      --stroke: #263047;
      --glow: rgba(0,0,0,.3);
      --text: #e8ecf4;
      --muted: #aeb7c8;
      --special: #ffd166;
      --btn: #1b2333;
      --btn-hover: #202a3f;
      --drag-handle: #8aa0c9;
      --drop-hint: #3357ff55;

      /* Player button visual tokens */
      --pbtn-bg1: #1c2741;
      --pbtn-bg2: #121b2f;
      --pbtn-border: #2b3854;
      --pbtn-hover1: #243253;
      --pbtn-hover2: #15203a;
      --pbtn-active: #0f1830;
      --pbtn-ring: rgba(120,175,255,.35);
      --pbtn-shadow: 0 10px 24px rgba(0,0,0,.35);
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body{
      margin:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans";
      -webkit-font-smoothing: antialiased;
      background:
        radial-gradient(1200px 600px at 50% -10%, #161a23 0%, #0e121a 50%, #090b10 100%),
        linear-gradient(180deg, var(--bg-1), var(--bg-2));
      color: var(--text);
      display: grid;
      place-items: center;
      min-height: 100vh;
      padding: 18px;
      overflow-x: hidden;
      overscroll-behavior: contain;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }

    .wrap{ width: min(96vw, var(--ring-width)); display:grid; gap: 14px; }
    .stage{ display: grid; gap: 14px; perspective: 1000px; }

    .ring{ position: relative; width: 100%; height: var(--ring-height);
           display: grid; grid-template-columns: 44px 1fr; align-items: stretch; }
    .drag-handle{
      user-select:none; -webkit-user-select:none;
      display:flex; align-items:center; justify-content:center;
      cursor: grab; font-size: 20px; color: var(--drag-handle);
      background: linear-gradient(180deg, #0e1423, #0b1120);
      border-radius: 12px; margin-right: 10px; border:1px solid #202a3f;
      min-width: 44px;
      touch-action: none; /* allow custom drag on touch */
    }
    .drag-handle:active{ cursor: grabbing; }

    .ring.dragging .card{
      box-shadow: inset 0 0 0 1px #2a3348, 0 16px 30px rgba(0,0,0,.45);
      transform: translateZ(0.1px) scale(1.01);
    }
    .ring.placeholder .card{
      opacity: .25;
      outline: 2px dashed var(--drag-handle);
    }

    .card{
      position: relative; width: 100%; height: 100%;
      display: grid; place-items: center; padding: 0 18px;
      border-radius: 14px;
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      box-shadow: inset 0 0 0 1px #2a3348, 0 10px 24px rgba(0,0,0,.28);
      color: var(--text);
      text-align: center; line-height: 1.25; letter-spacing: .2px;
      overflow: hidden; transform: translateZ(0.1px);
      backface-visibility: hidden; transform-style: preserve-3d;
    }

    .card > span{
      display:block; width: 100%; white-space: normal;
      font-size: clamp(14px, 4.0vw, 18px);
      word-break: normal;
    }

    @keyframes spinSmooth { from { transform: rotateY(0deg) translateZ(0.1px); }
                            to   { transform: rotateY(360deg) translateZ(0.1px); } }
    .spinning { animation: spinSmooth var(--spin-duration) linear; }

    .controls{ display:flex; gap:10px; justify-content:center; align-items:center; flex-wrap: wrap; }
    button{
      background: var(--btn); color: var(--text); border: 1px solid #2b3449;
      padding: 10px 16px; border-radius: 12px; cursor: pointer; font-weight: 700; letter-spacing: .2px;
      transition: transform .06s ease, background .2s ease, box-shadow .2s ease, border-color .2s ease;
      display: inline-flex; align-items: center; gap: 8px;
    }
    button:hover{ background:var(--btn-hover); border-color:#35415a; box-shadow: 0 6px 20px rgba(0,0,0,.25); }
    button:active{ transform: translateY(1px); }

    .tips{ color: var(--muted); font-size: 13px; text-align:center; margin-top: -6px; }

    .poem{
      background: linear-gradient(180deg, #101522, #0f1522);
      border: 1px solid #21283a; border-radius: 14px; padding: 14px 16px;
      box-shadow: 0 10px 28px rgba(0,0,0,.25), inset 0 0 0 1px #222b3e;
    }
    .poem-header{ display:flex; align-items:center; justify-content:center; gap:12px; margin-bottom:8px; }
    .poem h2{ margin: 0; font-size: 1rem; color: var(--muted); font-weight: 700; letter-spacing: .3px; }
    .special-badge{
      display:inline-flex; align-items:center; gap:6px;
      color: var(--special); background: rgba(255, 209, 102, 0.12);
      border: 1px solid rgba(255,209,102,0.45); border-radius: 999px;
      padding: 5px 10px; font-size: .88rem; font-weight: 700;
      filter: drop-shadow(0 0 6px rgba(255,209,102,.35));
    }
    .poem .quote{
      text-align:center;
      font-size: clamp(18px, 5.2vw, 32px);
      line-height: 1.35;
      word-break: normal;
    }
    .poem .byline{ margin-top: 6px; text-align:center; color: var(--muted); font-size: .95rem; font-style: italic; }

    .line { opacity: 0; transform: translateY(6px);
            animation: lineFade var(--line-fade-dur) ease forwards; }
    @keyframes lineFade { from { opacity: 0; transform: translateY(6px); }
                          to   { opacity: 1; transform: translateY(0); } }

    .music {
      display: grid; gap: 12px;
      background: linear-gradient(180deg, #0f1522, #0d1421);
      border: 1px solid #21283a; border-radius: 14px; padding: 12px 14px;
      box-shadow: 0 10px 28px rgba(0,0,0,.25), inset 0 0 0 1px #222b3e;
    }
    .music-row {
      display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap;
    }
    .ticker {
      position: relative; overflow: hidden; border:1px solid #242c3e; border-radius:10px;
      background: #0b1120; padding: 8px 12px; min-width: 240px; flex: 1;
    }
    .ticker__inner { display:inline-block; white-space: nowrap; padding-left:100%;
                     animation: slide 14s linear infinite; color: #5fb0ff; letter-spacing: .2px; }
    @keyframes slide { 0% { transform: translateX(0); } 100% { transform: translateX(-100%); } }

    /* Elegant player controls */
    .player-controls{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .pbtn{
      display:inline-flex; align-items:center; justify-content:center;
      width: 44px; height: 44px; border-radius: 999px;
      background: linear-gradient(180deg, var(--pbtn-bg1), var(--pbtn-bg2));
      border: 1px solid var(--pbtn-border);
      box-shadow: var(--pbtn-shadow), inset 0 0 0 1px rgba(255,255,255,0.03);
      color: var(--text); font-size: 18px; font-weight: 700;
      transition: transform .08s ease, background .2s ease, box-shadow .2s ease, border-color .2s ease, filter .2s ease;
      outline: none;
    }
    .pbtn:hover{
      background: linear-gradient(180deg, var(--pbtn-hover1), var(--pbtn-hover2));
      border-color: #3a4a6a;
      filter: drop-shadow(0 6px 16px rgba(0,0,0,.28));
    }
    .pbtn:active{ transform: translateY(1px); background: var(--pbtn-active); }
    .pbtn:focus-visible{ box-shadow: 0 0 0 3px var(--pbtn-ring); }

    .vol-wrap{
      display:inline-flex; align-items:center; gap:8px; margin-left: 8px; color: #aeb7c8;
      padding: 8px 10px; border-radius: 12px; border:1px solid #242c3e; background:#0b1120;
    }
    .vol-wrap input[type="range"]{ accent-color:#98d26c; width: 140px; }

    /* Options column (right side, stacked) */
    .options-col{
      display:flex; flex-direction:column; gap:8px; min-width: 140px;
    }
    .opt{
      display:flex; align-items:center; gap:10px;
      background:#0b1120; border:1px solid #242c3e; border-radius:10px; padding:8px 10px; color:#aeb7c8;
    }
    .opt input{ accent-color:#98d26c; }

    .player-row{
      display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap;
      background:#0c1220; border:1px solid #242c3e; border-radius:10px; padding:8px 12px;
    }
    .seek{ display:flex; align-items:center; gap:10px; flex:1; min-width: 160px; }
    .seek input[type="range"]{ width: 100%; accent-color:#98d26c; }
    .time { font-variant-numeric: tabular-nums; color: var(--muted); min-width: 94px; text-align:right; }

    /* Autoplay consent overlay */
    #audio-consent{
      display:none; position:fixed; inset:0;
      background: rgba(0,0,0,.7); backdrop-filter: blur(2px);
      z-index: 9999; color:#fff; align-items:center; justify-content:center; text-align:center; padding:24px;
    }
    #audio-consent .card{
      background:#11161c; border:1px solid #26313d; border-radius:14px; padding:18px 16px; max-width:520px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    #consent-msg{ font-size:.92rem; opacity:.9; }

    #testSpecialBtn { position:absolute; left:-9999px; top:auto; width:1px; height:1px; overflow:hidden; }

    /* ---------- Responsive ---------- */
    @media (max-width: 768px){
      :root{ --ring-width: 96vw; --ring-height: 68px; }
      body{ padding: 14px; }
      .wrap{ gap: 12px; }
      .stage{ gap: 12px; }
      .drag-handle{ font-size: 18px; min-width: 40px; }
      .poem .quote{ font-size: clamp(18px, 4.8vw, 28px); }
      .controls button{ padding: 10px 14px; }
      .ticker{ min-width: 200px; }
      .player-row{ gap: 8px; }
      .options-col{ min-width: 120px; }
    }

    @media (max-width: 480px){
      :root{ --ring-width: 96vw; --ring-height: 56px; }
      body{ padding: 10px; }
      .wrap{ gap: 10px; }
      .stage{ gap: 10px; }
      .drag-handle{ font-size: 18px; min-width: 36px; }
      .card{ padding: 0 14px; }
      .card > span{ font-size: clamp(14px, 4.5vw, 17px); }

      .controls{ gap: 8px; }
      .controls button{ padding: 10px 12px; }

      .music{ gap: 10px; padding: 10px 12px; }
      .music-row{ flex-direction: column; align-items: stretch; gap: 10px; }
      .ticker{ min-width: 0; width: 100%; }
      .player-controls{ justify-content:center; }
      .options-col{ flex-direction:row; justify-content:center; gap:12px; }
      .opt{ width:auto; }
      .player-row{ flex-direction: column; align-items: stretch; gap: 8px; }
      .seek{ min-width: 0; }
      .time{ text-align: left; }
      .vol-wrap input[type="range"]{ width: 120px; }
    }

    /* === Strict ruleset-safe patches === */
    .options-box{
      display:flex;
      justify-content:flex-start;
      align-items:center;
      margin-top:8px;
    }
    .options-box .options-col{
      display:flex !important;
      flex-direction: row !important;  /* horizontal: Play All then Repeat */
      align-items:center;
      gap:12px;                         /* spacing */
    }
    .options-box .options-col .opt{
      display:flex;
      align-items:center;
      gap:8px;
      white-space:nowrap;
    }

    /* Ensure the player icons are visibly sized inside the circular buttons */
    .pbtn svg{ width:28px; height:28px; }

    /* Ensure touch/absolute drag computes against the correct container */
    .stage{ position: relative; }

    /* Prevent touch scroll from hijacking drag on mobile */
    .drag-handle{ touch-action: none; -ms-touch-action: none; }
  </style>
</head>
<body>
  <!-- Autoplay consent (shown only if autoplay is blocked) -->
  <div id="audio-consent" aria-hidden="true">
    <div class="card">
      <h2 style="margin:0 0 8px;">Enable sound?</h2>
      <p id="consent-msg" style="margin:0 0 16px;">Tap once to allow background music. We’ll remember this for next time.</p>
      <button id="audio-consent-btn" style="padding:10px 16px; border:0; border-radius:8px; font-weight:600; cursor:pointer;">Enable Sound</button>
    </div>
  </div>

  <!-- Hidden special-test button (also Shift+S) -->
  <button id="testSpecialBtn" aria-label="Generate special poem">hidden</button>

  <div class="wrap">
    <div class="stage" id="stage"></div>
    <div class="tips">Drag the ⋮⋮ handle to reorder rings (top = first line)</div>

    <div class="controls">
      <button id="spinBtn">✨ Create Your Next Poem</button>
      <button id="copyBtn">📋 Copy poem</button>
    </div>

    <div class="poem" id="poemBox" aria-live="polite">
      <div class="poem-header">
        <h2>Current Poem</h2>
      </div>
      <div id="poemFormatted" class="quote"></div>
      <div class="byline">~ by Aramish</div>
    </div>

    <section class="music" aria-label="Music player">
      <div class="music-row">
        <div class="ticker" title="Current song"><div id="songTitle" class="ticker__inner">—</div></div>

        <!-- Player controls -->
        <div class="player-controls" aria-label="Playback controls">
          <button id="prevBtn" class="pbtn" title="Previous" aria-label="Previous track">⏮️</button>
          <button id="playPauseBtn" class="pbtn" title="Play/Pause" aria-label="Play or pause">▶️</button>
          <button id="stopBtn" class="pbtn" title="Stop" aria-label="Stop">⏹️</button>
          <button id="nextBtn" class="pbtn" title="Next" aria-label="Next track">⏭️</button>
          <span class="vol-wrap" aria-label="Volume">
            Vol <input id="volRange" type="range" min="0" max="1" step="0.01" value="0.6" />
          </span>
        </div>
      </div>

      <div class="player-row">
        <div class="seek">
          <input id="seekRange" type="range" min="0" max="0" step="0.01" value="0" />
        </div>

        <div class="options-box">
          <div class="options-col" aria-label="Playback options">
            <!-- FIX: make Play All truly pre-checked -->
            <label class="opt"><input id="optPlayAll" type="checkbox" checked /> Play All</label>
            <label class="opt"><input id="optRepeat"  type="checkbox" /> Repeat</label>
          </div>
        </div>

        <div class="time"><span id="curTime">0:00</span> / <span id="durTime">0:00</span></div>
      </div>

      <!-- Two audio elements for seamless crossfade -->
      <audio id="playerA" preload="auto" crossorigin="anonymous"></audio>
      <audio id="playerB" preload="auto" crossorigin="anonymous"></audio>
    </section>
  </div>

<script>
/* ======== POEMS: 5 rings × 4 lines ======== */
const RINGS_DATA = [
  ["Strength in Silence,","Grace Without Seeking, Calm in a Storm,","The World Bends Gentler Near her Soul","She is Proof That Kindness is a Force"],
  ["Hope Carried in Quiet Hands,","Stillness that softens the Sharpest Edge,","She Listens Where Most Would Speak","And Builds with the Weight of Care"],
  ["She Moves Like Morning Light,","Patience Carved into the Day,","Every Step Writes Peace in Stone","Her Silence Steadies The Storm"],
  ["Gentle As the Breath Before Dawn,","Her Voice Mends What fear has Broken,","Fire Wrapped in Grace,","Kindness Carved into Motion"],
  ["Dream in the Dawn,","Truth Without Armor, Steady in Light","The Horizon Waits for her Journey","She is Proof That Fate Wears Many Faces"]
];
let stacks = [];  // [{id, options:[...], currentIndex, card, span, el }]

/* ---- SPECIAL POEM (strict) ---- */
function normalizeLineStrict(s){
  return String(s || "")
    .replace(/[“”"']/g, "")
    .replace(/\s*[,;:!?]+$/g, "")
    .replace(/\s+/g, " ")
    .trim()
    .toLowerCase();
}
function isSpecialPoem(){
  const now = currentLines().map(normalizeLineStrict);
  return now.length === 5 &&
         now[0] === "strength in silence" &&
         now[1] === "stillness that softens the sharpest edge" &&
         now[2] === "every step writes peace in stone" &&
         now[3] === "her voice mends what fear has broken" &&
         now[4] === "the horizon waits for her journey";
}
const SPECIAL_TRACK = { name: "Sparks_For_Only_You.mp3", url: "music/" + encodeURIComponent("Sparks_For_Only_You.mp3") };

/* ======== MUSIC (library supplied by index.js via window.LIBRARY) ======== */
const BAD_TRACKS = new Set(); // fatal-only blacklist
let LIBRARY = window.LIBRARY || [];
let bag = [], bagPos = -1, currentIndex = -1;

/* Playback options */
const optPlayAll = document.getElementById('optPlayAll');
const optRepeat  = document.getElementById('optRepeat');

function loadOptions(){
  optPlayAll.checked = localStorage.getItem('poem_playAll') === '1' || optPlayAll.checked;
  optRepeat.checked  = localStorage.getItem('poem_repeat')  === '1';
}
function saveOptions(){
  localStorage.setItem('poem_playAll', optPlayAll.checked ? '1' : '0');
  localStorage.setItem('poem_repeat',  optRepeat.checked  ? '1' : '0');
}
optPlayAll.addEventListener('change', saveOptions);
optRepeat.addEventListener('change',  saveOptions);

/* Wait for tracks.json */
function waitForLibraryReady(){
  return new Promise((resolve) => {
    if (window.LIBRARY && window.LIBRARY.length) return resolve();
    if (window.musicReady && typeof window.musicReady.then === 'function'){
      window.musicReady.then(resolve); return;
    }
    window.addEventListener('musicReady', resolve, { once: true });
  });
}

function shuffle(arr){ for (let i = arr.length - 1; i > 0; i--){ const j = Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }
function rebuildBag(){ bag = LIBRARY.map((_,i)=>i).filter(i => !BAD_TRACKS.has(LIBRARY[i].name)); if (!bag.length) bag = LIBRARY.map((_,i)=>i); shuffle(bag); bagPos=-1; }
function nextFromBag(){ if (!bag.length) rebuildBag(); bagPos++; if (bagPos>=bag.length){ rebuildBag(); bagPos=0; } return bag[bagPos]; }
function prevFromBag(){ if (!bag.length) rebuildBag(); bagPos--; if (bagPos<0){ rebuildBag(); bagPos=bag.length-1; } return bag[bagPos]; }

/* ======== DOM ======== */
const stage = document.getElementById('stage');
const songTitleEl = document.getElementById('songTitle');
const playerA = document.getElementById('playerA');
const playerB = document.getElementById('playerB');
const volRange = document.getElementById('volRange');
const playPauseBtn = document.getElementById('playPauseBtn');
const stopBtn = document.getElementById('stopBtn');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const seekRange = document.getElementById('seekRange');
const curTimeEl = document.getElementById('curTime');
const durTimeEl = document.getElementById('durTime');

/* ======== Build Reorderable Rings ======== */
function buildRings(){
  stage.innerHTML = "";
  stacks = [];
  for (let i = 0; i < RINGS_DATA.length; i++){
    const el = document.createElement('div');
    el.className = 'ring';
    el.draggable = true;                 // Entire ring is the drag source (desktop)
    el.dataset.idx = String(i);

    const drag = document.createElement('div');
    drag.className = 'drag-handle';
    drag.title = "Drag to reorder";
    drag.textContent = "⋮⋮";
    /* IMPORTANT: do NOT set the handle as draggable */

    const card = document.createElement('div'); 
    card.className = 'card';
    const span = document.createElement('span'); 
    span.textContent = RINGS_DATA[i][0];
    card.appendChild(span);

    el.appendChild(drag);
    el.appendChild(card);
    stage.appendChild(el);

    stacks.push({ id:i, options:[...RINGS_DATA[i]], currentIndex:0, card, span, el });
  }
  wireDesktopDnD();
  wireTouchDnD();
}

/* Desktop Drag & Drop */
function wireDesktopDnD(){
  let dragSrcRing = null;

  // Drag starts/ends on the ring (source = ring)
  stage.querySelectorAll('.ring').forEach(ring => {
    ring.addEventListener('dragstart', (e) => {
      dragSrcRing = ring;
      try { e.dataTransfer.setData('text/plain', 'ring'); } catch(_) {} // improves Safari reliability
      e.dataTransfer.effectAllowed = 'move';
      ring.classList.add('drag-over');
    });
    ring.addEventListener('dragend', () => {
      stage.querySelectorAll('.ring').forEach(el => el.classList.remove('drag-over','drop-before','drop-after'));
      dragSrcRing = null;
    });
  });

  // DELEGATION so children count as valid targets
  stage.addEventListener('dragover', (e) => {
    if (!dragSrcRing) return;
    const ring = e.target.closest('.ring');
    if (!ring) return;
    e.preventDefault(); // REQUIRED so drop will fire on this target
    const rect = ring.getBoundingClientRect();
    const midY = rect.top + rect.height/2;
    ring.classList.add('drag-over');
    ring.classList.toggle('drop-before', e.clientY < midY);
    ring.classList.toggle('drop-after',  e.clientY >= midY);
    try { e.dataTransfer.dropEffect = 'move'; } catch(_) {}
  });

  stage.addEventListener('dragleave', (e) => {
    const ring = e.target.closest('.ring');
    if (ring) ring.classList.remove('drop-before','drop-after');
  });

  stage.addEventListener('drop', (e) => {
    if (!dragSrcRing) return;
    const ring = e.target.closest('.ring');
    if (!ring) return;
    e.preventDefault();

    if (dragSrcRing !== ring){
      const rect = ring.getBoundingClientRect();
      const midY = rect.top + rect.height/2;
      const dropBefore = e.clientY < midY;

      if (dropBefore) stage.insertBefore(dragSrcRing, ring);
      else            stage.insertBefore(dragSrcRing, ring.nextSibling);

      // Rebuild stacks to match DOM order
      const newStacks = [];
      stage.querySelectorAll('.ring').forEach(row => {
        const found = stacks.find(s => s.el === row);
        if (found) newStacks.push(found);
      });
      stacks = newStacks;

      // Update poem immediately after movement
      renderPoem(true);
    }

    stage.querySelectorAll('.ring').forEach(el => el.classList.remove('drag-over','drop-before','drop-after'));
    dragSrcRing = null;
  });
}


/* Touch/Pointer Drag & Drop for mobile */
function wireTouchDnD(){
  const rings = Array.from(stage.querySelectorAll('.ring'));
  rings.forEach(ring => {
    const handle = ring.querySelector('.drag-handle');
    if (!handle) return;
    let dragging=false, draggedEl=null, placeholder=null, currentY=0;
    const moveDragged = (ev) => {
      const y = (ev.clientY || (ev.touches && ev.touches[0].clientY) || currentY);
      currentY = y;
      const stageRect = stage.getBoundingClientRect();
      const targetTop = y - stageRect.top - (draggedEl.offsetHeight/2);
      draggedEl.style.top = Math.max(0, targetTop) + 'px';
      const el = document.elementFromPoint(stageRect.left + draggedEl.offsetWidth/2 + 1, y);
      const ringUnder = el ? el.closest('.ring') : null;
      if (ringUnder && ringUnder !== draggedEl && ringUnder !== placeholder){
        const rect = ringUnder.getBoundingClientRect();
        const midY = rect.top + rect.height/2;
        if (y < midY) stage.insertBefore(placeholder, ringUnder);
        else          stage.insertBefore(placeholder, ringUnder.nextSibling);
      }
    };
    const start = (ev) => {
      if ((ev.pointerType && ev.pointerType!=='touch' && ev.pointerType!=='mouse') || (ev.button!==undefined && ev.button!==0)) return;
      ev.preventDefault();
      draggedEl = ring; dragging=true; ring.classList.add('dragging');
      placeholder = document.createElement('div'); placeholder.className='ring placeholder'; placeholder.style.height=getComputedStyle(ring).height;
      const phc=document.createElement('div'); phc.className='card'; placeholder.appendChild(phc);
      ring.parentNode.insertBefore(placeholder, ring.nextSibling);
      const rect = ring.getBoundingClientRect(), stageRect = stage.getBoundingClientRect();
      ring.style.position='absolute'; ring.style.left = rect.left - stageRect.left + 'px';
      ring.style.width = rect.width + 'px'; ring.style.zIndex = 1000;
      moveDragged(ev);
      const up = (e)=>{ e.preventDefault(); finish(); window.removeEventListener('pointermove', move, {passive:false}); window.removeEventListener('touchmove', move, {passive:false}); };
      const move = (e)=>{ if(!dragging) return; e.preventDefault(); moveDragged(e); };
      window.addEventListener('pointermove', move, {passive:false});
      window.addEventListener('pointerup',   up,   {passive:false, once:true});
      window.addEventListener('pointercancel', up, {passive:false, once:true});
      window.addEventListener('touchmove', move, {passive:false});
      window.addEventListener('touchend',  up,   {passive:false, once:true});
      window.addEventListener('touchcancel', up, {passive:false, once:true});
    };
    const finish = () => {
      if (!dragging) return;
      if (placeholder && placeholder.parentNode){ stage.insertBefore(ring, placeholder); placeholder.remove(); }
      ring.style.position=''; ring.style.left=''; ring.style.top=''; ring.style.width=''; ring.style.zIndex='';
      ring.classList.remove('dragging'); dragging=false; draggedEl=null; placeholder=null;
      rebuildStacksFromDOM();
      renderPoem(true); // <-- ensure poem reflects new order on touch
    };
    if (window.PointerEvent) handle.addEventListener('pointerdown', start, {passive:false});
    else handle.addEventListener('touchstart', (e)=>start(e), {passive:false});
  });
}
function rebuildStacksFromDOM(){
  const newStacks = [];
  stage.querySelectorAll('.ring').forEach(row => {
    const found = stacks.find(s => s.el === row);
    if (found) newStacks.push(found);
  });
  stacks = newStacks;
}

/* ======== Current lines & rendering ======== */
function currentLines(){ return stacks.map(s => s.options[s.currentIndex]); }

function setSpecialBadge(active){
  const header = document.querySelector('.poem-header');
  let badge = document.getElementById('specialBadge');
  if (active){
    if (!badge){
      badge = document.createElement('span');
      badge.id = 'specialBadge';
      badge.className = 'special-badge';
      badge.innerHTML = '<span class="star">✨</span> Special Poem';
      header.appendChild(badge);
    }
  } else if (badge) badge.remove();
}
function escapeHTML(s){ return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function renderPoem(animated=false){
  const lines = currentLines();
  const quote = document.getElementById('poemFormatted');
  if (!animated){
    quote.innerHTML = '<em>"' + lines.map(escapeHTML).join('<br>') + '"</em>';
  } else {
    const stagger = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--line-stagger')) || 300;
    let html = '<em>"';
    for (let i=0;i<lines.length;i++){
      html += `<span class="line" style="animation-delay:${i*stagger}ms">${escapeHTML(lines[i])}</span>`;
      if (i < lines.length-1) html += '<br>';
    }
    html += '"</em>';
    quote.innerHTML = html;
  }
  setSpecialBadge(isSpecialPoem());
}

/* ======== Spin logic (stair) ======== */
function parseTimeToMs(val){ if (!val) return 0; if (val.endsWith('ms')) return parseFloat(val); if (val.endsWith('s')) return parseFloat(val)*1000; return parseFloat(val)||0; }
function startSpin(card){ card.classList.remove('spinning'); void card.offsetWidth; card.classList.add('spinning'); }
function stopSpin(card){ card.classList.remove('spinning'); }

function unlockAudioOnce(){
  const active = getActive();
  if (active._unlocked) return;
  try {
    active.volume = Number(volRange.value || 0.6);
    const p = active.play();
    if (p && p.then){
      p.then(() => { active.pause(); active.currentTime = 0; active._unlocked = true; })
       .catch(() => { active._unlocked = true; });
    } else { active._unlocked = true; }
  } catch { active._unlocked = true; }
}

function spinStair(){
  unlockAudioOnce();

  const spinDur = parseTimeToMs(getComputedStyle(document.documentElement).getPropertyValue('--spin-duration').trim());
  const offset = spinDur * parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--stair-fraction') || 0.25);
  const nextIndices = stacks.map(s => Math.floor(Math.random() * s.options.length));
  const lastMidSwapTime = (stacks.length - 1) * offset + spinDur * 0.5;

  stacks.forEach((s, idx) => {
    const startDelay = idx * offset;
    setTimeout(() => startSpin(s.card), startDelay);
    setTimeout(() => { s.currentIndex = nextIndices[idx]; s.span.textContent = s.options[nextIndices[idx]]; }, startDelay + spinDur * 0.5);
    setTimeout(() => stopSpin(s.card), startDelay + spinDur + 20);
  });

  setTimeout(async () => {
    renderPoem(true);
    if (isSpecialPoem()){
      await playIndexForSpecial();
    } else {
      const idx = nextFromBag();
      if (typeof idx === 'number') await playIndex(idx, {loop:false, advanceBagOnSuccess:true, crossfade:true});
    }
  }, lastMidSwapTime + 60);
}

/* ======== Music player with crossfade ======== */
function prettyName(filename){ return String(filename).replace(/\.[^/.]+$/,"").replace(/_/g," ").replace(/-/g," ").trim(); }
function formatTime(t){ if (!isFinite(t)) return "0:00"; const m = Math.floor(t/60), s = Math.floor(t%60); return m + ":" + String(s).padStart(2,"0"); }
function resetSeekUI(){ seekRange.value = 0; seekRange.max = 0; curTimeEl.textContent = "0:00"; durTimeEl.textContent = "0:00"; }

let ACTIVE = 'A'; // which audio element is active: 'A' or 'B'
function getActive(){ return ACTIVE === 'A' ? playerA : playerB; }
function getIdle(){ return ACTIVE === 'A' ? playerB : playerA; }
function swapPlayers(){ ACTIVE = (ACTIVE === 'A' ? 'B' : 'A'); }

/* Keep UI updated for whichever player is active */
function updateDurAndSeekOn(active){
  seekRange.max = isFinite(active.duration) ? active.duration : 0;
  durTimeEl.textContent = formatTime(active.duration);
}
function updatePlayStateUI(){
  const active = getActive();
  playPauseBtn.textContent = active.paused ? "▶️" : "⏸️";
}
function setTitle(tr, extra = ""){
  songTitleEl.textContent = "♪ " + prettyName(tr.name) + (extra ? " " + extra : "");
}
function isFatalAudioError(audio){
  const c = audio && audio.error && audio.error.code;
  return c === 3 || c === 4;
}

/* Volume handling */
function setMasterVolume(v){
  v = Math.max(0, Math.min(1, v));
  getActive().volume = v;
}
volRange.addEventListener('input', () => setMasterVolume(Number(volRange.value)));

/* Crossfade helper: linear fade between active and idle over --xfade-ms */
function getXfadeMs(){
  const v = getComputedStyle(document.documentElement).getPropertyValue('--xfade-ms').trim();
  if (!v) return 1800;
  if (v.endsWith('ms')) return parseFloat(v)||1800;
  if (v.endsWith('s')) return (parseFloat(v)||1.8)*1000;
  return parseFloat(v)||1800;
}

async function crossfadeTo(url, titleObj){
  const active = getActive();
  const idle = getIdle();
  const targetVol = Number(volRange.value || 0.6);

  // Prepare idle
  idle.onended = null;
  idle.loop = false;
  idle.src = url;
  idle.load();
  idle.volume = 0;

  try { await idle.play(); } catch(e) {}

  // Fade
  const dur = getXfadeMs();
  const steps = Math.max(10, Math.floor(dur / 30));
  let step = 0;

  return new Promise((resolve) => {
    const tick = () => {
      step++;
      const t = step / steps;
      active.volume = targetVol * (1 - t);
      idle.volume   = targetVol * (t);
      if (step >= steps){
        active.pause();
        active.currentTime = 0;
        idle.volume = targetVol;
        swapPlayers();
        resetSeekUI();
        if (isFinite(getActive().duration)) updateDurAndSeekOn(getActive());
        setTitle(titleObj);
        hookEnded(); // reattach onended to the new active
        updatePlayStateUI();
        resolve();
        return;
      }
      requestAnimationFrame(tick);
    };
    requestAnimationFrame(tick);
  });
}

/* Simple load (no crossfade) onto active */
async function loadPlayOnActive(url, titleObj, {loop=false}={}){
  const active = getActive();
  active.onended = null;
  active.loop = loop;
  active.src = url;
  active.load();
  try { await active.play(); } catch(e){}
  setTitle(titleObj);
  resetSeekUI();
  updateDurAndSeekOn(active);
  updatePlayStateUI();
  hookEnded();
}

/* Auto-advance on end (with crossfade) honoring Play All / Repeat */
function hookEnded(){
  const active = getActive();
  active.onended = async () => {
    if (optRepeat.checked){
      active.currentTime = 0;
      try { await active.play(); } catch(e) {}
      return;
    }
    if (optPlayAll.checked){
      const nxt = nextFromBag();
      if (typeof nxt !== 'number') return;
      const tr = LIBRARY[nxt];
      await crossfadeTo(tr.url, tr);
      currentIndex = nxt;
    }
    // If neither option checked: stop after current track
  };
}

/* Public controls, using the library "bag" */
async function playIndex(i, {loop=false, advanceBagOnSuccess=false, crossfade=false} = {}){
  if (i < 0 || i >= LIBRARY.length) return;
  const tr = LIBRARY[i];
  try{
    if (crossfade && !getActive().paused){
      await crossfadeTo(tr.url, tr);
    } else {
      await loadPlayOnActive(tr.url, tr, {loop});
    }
    currentIndex = i;
    if (advanceBagOnSuccess){
      const pos = bag.indexOf(i);
      if (pos !== -1) bagPos = pos;
    }
  } catch(e){
    if (isFatalAudioError(getActive())){
      BAD_TRACKS.add(tr.name);
      rebuildBag();
      const nxt = nextFromBag();
      if (typeof nxt === 'number'){ await playIndex(nxt, {loop:false, advanceBagOnSuccess:true, crossfade:false}); return; }
    }
    setTitle({name:"Audio error."});
  }
}

async function playIndexForSpecial(){
  try{
    // Stop both, then load special onto active and loop
    playerA.pause(); playerB.pause();
    playerA.currentTime = 0; playerB.currentTime = 0;
    if (ACTIVE !== 'A') swapPlayers(); // deterministic

    await loadPlayOnActive(SPECIAL_TRACK.url, {name: SPECIAL_TRACK.name + " — special"}, {loop:true});
  } catch(e){
    setTitle({name:"Audio error (special)."});
  }
}

/* Player events (active only) */
let seeking = false;
function activeLoadedMeta(){
  const active = getActive();
  seekRange.max = isFinite(active.duration) ? active.duration : 0;
  durTimeEl.textContent = formatTime(active.duration);
}
function activeTimeUpdate(){
  if (seeking) return;
  const active = getActive();
  seekRange.value = active.currentTime || 0;
  curTimeEl.textContent = formatTime(active.currentTime);
}
playerA.addEventListener('loadedmetadata', activeLoadedMeta);
playerB.addEventListener('loadedmetadata', activeLoadedMeta);
playerA.addEventListener('timeupdate', activeTimeUpdate);
playerB.addEventListener('timeupdate', activeTimeUpdate);

seekRange.addEventListener('input', () => { seeking = true; curTimeEl.textContent = formatTime(Number(seekRange.value)); });
seekRange.addEventListener('change', () => {
  const active = getActive();
  active.currentTime = Number(seekRange.value);
  seeking = false;
});
playPauseBtn.addEventListener('click', async () => {
  const active = getActive();
  if (active.paused){ try{ await active.play(); }catch{} }
  else { active.pause(); }
  updatePlayStateUI();
});
stopBtn.addEventListener('click', () => {
  const active = getActive(), idle = getIdle();
  // quick fadeout (300ms)
  const startVol = active.volume, dur = 300, steps = Math.max(6, Math.floor(dur/30));
  let step=0;
  const tick = () => {
    step++;
    const t = step/steps;
    active.volume = startVol*(1-t);
    if (step>=steps){
      active.pause(); active.currentTime=0; idle.pause(); idle.currentTime=0;
      active.volume = Number(volRange.value || 0.6);
      updatePlayStateUI(); resetSeekUI();
      return;
    }
    requestAnimationFrame(tick);
  };
  requestAnimationFrame(tick);
});
prevBtn.addEventListener('click', async () => {
  const idx = prevFromBag();
  if (typeof idx === 'number') await playIndex(idx, {loop:false, advanceBagOnSuccess:true, crossfade:true});
});
nextBtn.addEventListener('click', async () => {
  const idx = nextFromBag();
  if (typeof idx === 'number') await playIndex(idx, {loop:false, advanceBagOnSuccess:true, crossfade:true});
});

/* ======== Copy ======== */
document.getElementById('copyBtn').addEventListener('click', async () => {
  const poem = '"' + currentLines().join('\n') + '"';
  const text = '*' + poem + '* ~ by Aramish';
  try{
    await navigator.clipboard.writeText(text);
    const b = document.getElementById('copyBtn'); const old = b.textContent; b.textContent = '✅ Copied';
    setTimeout(()=> b.textContent = old, 1200);
  }catch{ alert('Copy failed. You can select and copy from the poem box.'); }
});

/* ======== AUTOPLAY (on open): try; if blocked, show consent ======== */
async function tryStartRandomSong() {
  await waitForLibraryReady();
  LIBRARY = window.LIBRARY || [];
  if (!LIBRARY.length) return false;
  rebuildBag();
  try {
    const idx = nextFromBag();
    if (typeof idx === 'number') {
      await playIndex(idx, { loop:false, advanceBagOnSuccess:true, crossfade:false });
      return true;
    }
    return false;
  } catch(e){ return false; }
}
function showAudioConsentOverlay() {
  const overlay = document.getElementById('audio-consent');
  const btn = document.getElementById('audio-consent-btn');
  const msg = document.getElementById('consent-msg');
  if (!overlay || !btn) return;
  overlay.style.display = 'flex';
  const enable = async () => {
    const ok = await tryStartRandomSong();
    if (ok) {
      overlay.style.display = 'none';
      return;
    }
    if (msg) msg.textContent = "Tap ▶️ once, then tap Enable Sound again.";
  };
  btn.onclick = enable;
  overlay.addEventListener('click', (e) => { if (e.target === overlay) enable(); });
}

/* ======== Buttons & Init ======== */
document.getElementById('spinBtn').addEventListener('click', spinStair);

function initVolume(){
  const savedVol = Number(localStorage.getItem('poem_vol'));
  const v = Number.isNaN(savedVol) ? Number(volRange.value) : Math.max(0, Math.min(1, savedVol));
  playerA.volume = v; playerB.volume = 0; // active starts A
  volRange.value = String(v);
  volRange.addEventListener('input', () => {
    const val = Number(volRange.value);
    getActive().volume = val;
    localStorage.setItem('poem_vol', String(val));
  });
}

/* Persisted toggles */
function loadPersisted(){
  loadOptions();
}

/* Build & start (v44 look preserved) */
buildRings();
renderPoem(true);
initVolume();
loadPersisted();

/* Wait for the music library and attempt autoplay */
waitForLibraryReady().then(() => {
  LIBRARY = window.LIBRARY || [];
  rebuildBag();
  seekRange.value = 0;
  // Try autoplay; if blocked, show consent overlay
  tryStartRandomSong().then((ok) => { if (!ok) showAudioConsentOverlay(); });
});

/* Hidden special test: Shift+S */
document.getElementById('testSpecialBtn').addEventListener('click', generateSpecialPoem);
document.addEventListener('keydown', (e) => { if (e.key.toLowerCase() === 's' && e.shiftKey) generateSpecialPoem(); });
function generateSpecialPoem(){
  const picks = [0, 1, 2, 1, 2];
  picks.forEach((idx, i) => {
    stacks[i].currentIndex = idx;
    stacks[i].span.textContent = stacks[i].options[idx];
  });
  renderPoem(true);
  playIndexForSpecial();
}
</script>
</body>
</html>
