<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover"
  />
  <title>Environment — Wind & Leaves (Background)</title>
  <style>
    /* Transparent page — lets your main page background show through */
    html, body {
      height: 100%;
      margin: 0;
      background: transparent;         /* IMPORTANT: do not paint background */
      overflow: hidden;
    }
    /* Full-screen canvas; never capture input */
    #bg-canvas{
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;            /* keeps clicks/touches for host page */
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="bg-canvas" aria-hidden="true"></canvas>

  <script>
  /* ===========================================================
     Minimal line-art “wind + leaves” background (canvas)
     - Transparent page (no background fill)
     - Slower gusts (~4.4–6.4s)
     - 20–40 outlined leaves per gust (10×)
     - More visible leaves (thicker + higher alpha + subtle accent vein)
     - Input-safe (pointer-events: none)
     - Pauses when tab/iframe not visible (perf-friendly)
     =========================================================== */

  (() => {
    const canvas = document.getElementById('bg-canvas');
    const ctx = canvas.getContext('2d', { alpha: true });
    let rafId = 0;

    // Cap DPR for perf; draw in CSS pixels via setTransform
    let dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    let W = 0, H = 0;

    function resize(){
      const { innerWidth, innerHeight } = window;
      W = Math.floor(innerWidth * dpr);
      H = Math.floor(innerHeight * dpr);
      canvas.width = W; canvas.height = H;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
    }
    resize();
    window.addEventListener('resize', () => {
      dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      resize();
    });

    // Soft palette that sits nicely on your dark theme
    const WIND_COLOR = 'rgba(95,176,255,0.18)';   // cyan line
    const LEAF_COLOR = 'rgba(205,214,231,0.6)';   // brighter leaf outline
    const VEIN_COLOR = 'rgba(95,176,255,0.5)';    // subtle accent vein

    // Gust system
    const gusts = [];
    const MAX_GUSTS = 2; // keep it gentle
    let lastSpawn = 0;
    let spawnInterval = randRange(15000, 22000);

    function randRange(min, max){ return Math.random() * (max - min) + min; }

    function makePath(yBase, dir=1){
      const vw = window.innerWidth;
      const left = -0.1 * vw;              // start slightly off-screen
      const right = vw * 1.1;              // end slightly off-screen
      const y1 = yBase + randRange(-40, 40);
      const y2 = yBase + randRange(-60, 60) * dir;
      const cp1x = randRange(vw*0.2, vw*0.35);
      const cp2x = randRange(vw*0.65, vw*0.8);
      const cp1y = yBase + randRange(-80, 80) * dir;
      const cp2y = yBase + randRange(-80, 80) * -dir;

      return {
        x0: left,  y0: y1,
        x1: cp1x,  y1: cp1y,
        x2: cp2x,  y2: cp2y,
        x3: right, y3: y2
      };
    }

    function cubicPoint(t, p){
      const u = 1 - t;
      const x = u*u*u*p.x0 + 3*u*u*t*p.x1 + 3*u*t*t*p.x2 + t*t*t*p.x3;
      const y = u*u*u*p.y0 + 3*u*u*t*p.y1 + 3*u*t*t*p.y2 + t*t*t*p.y3;
      return {x, y};
    }
    function cubicTangent(t, p){
      const u = 1 - t;
      const x = 3*u*u*(p.x1 - p.x0) + 6*u*t*(p.x2 - p.x1) + 3*t*t*(p.x3 - p.x2);
      const y = 3*u*u*(p.y1 - p.y0) + 6*u*t*(p.y2 - p.y1) + 3*t*t*(p.y3 - p.y2);
      return {x, y};
    }

    function spawnGust(){
      if (gusts.length >= MAX_GUSTS) return;

      const yBase = randRange(window.innerHeight*0.25, window.innerHeight*0.75);
      const dir = Math.random() < 0.5 ? 1 : -1;
      const path = makePath(yBase, dir);

      // Slower + fuller per your latest request
      const duration = randRange(4400, 6400);
      const leavesCount = Math.floor(randRange(20, 40));

      const now = performance.now();
      const leaves = Array.from({length: leavesCount}).map((_, i) => ({
        offset: Math.random()*0.25 + i*(0.75/leavesCount), // even spread
        rot: randRange(-Math.PI, Math.PI),
        rotSpeed: randRange(-0.9, 0.9)
      }));

      gusts.push({ start: now, end: now + duration, path, leaves });
    }

    function drawLeaf(x, y, angle, scale){
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.scale(scale, scale);

      // Visible outline
      ctx.strokeStyle = LEAF_COLOR;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(10, -6, 18, 0);  // upper contour
      ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(10, 6, 18, 0);   // lower contour
      ctx.stroke();

      // Subtle accent mid-vein
      ctx.strokeStyle = VEIN_COLOR;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(3, 0);
      ctx.lineTo(15, 0);
      ctx.stroke();

      ctx.restore();
    }

    function drawGust(g){
      const now = performance.now();
      const t = (now - g.start) / (g.end - g.start); // 0..1
      if (t >= 1) return false;

      // Bell fade
      let alpha = Math.sin(Math.PI * t);
      alpha = Math.max(0, Math.min(1, alpha));

      // Wind line (bezier)
      ctx.save();
      ctx.globalAlpha = alpha * 0.8;
      ctx.strokeStyle = WIND_COLOR;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(g.path.x0, g.path.y0);
      ctx.bezierCurveTo(g.path.x1, g.path.y1, g.path.x2, g.path.y2, g.path.x3, g.path.y3);
      ctx.stroke();
      ctx.restore();

      // Leaves
      for (const leaf of g.leaves){
        const lt = Math.min(1, Math.max(0, t + leaf.offset));
        const p = cubicPoint(lt, g.path);
        const tan = cubicTangent(lt, g.path);
        const ang = Math.atan2(tan.y, tan.x) + leaf.rot;
        const scale = 0.9 + Math.sin(lt * Math.PI) * 0.2;

        ctx.save();
        ctx.globalAlpha = alpha * 0.95; // slightly stronger for visibility
        drawLeaf(p.x, p.y, ang, scale);
        ctx.restore();

        leaf.rot += leaf.rotSpeed * 0.016;
      }

      return true;
    }

    function frame(){
      ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

      // Draw + cull
      for (let i = gusts.length - 1; i >= 0; i--){
        if (!drawGust(gusts[i])) gusts.splice(i, 1);
      }

      // Natural spawn rhythm
      const now = performance.now();
      if (now - lastSpawn > spawnInterval){
        spawnGust();
        lastSpawn = now;
        spawnInterval = randRange(15000, 22000);
      }

      rafId = requestAnimationFrame(frame);
    }

    // Pause/Resume when hidden for perf
    function onVis(){
      if (document.hidden){
        cancelAnimationFrame(rafId);
        rafId = 0;
      } else if (!rafId){
        lastSpawn = performance.now();
        rafId = requestAnimationFrame(frame);
      }
    }
    document.addEventListener('visibilitychange', onVis);

    // Start
    lastSpawn = performance.now();
    rafId = requestAnimationFrame(frame);
  })();
  </script>
</body>
</html>
